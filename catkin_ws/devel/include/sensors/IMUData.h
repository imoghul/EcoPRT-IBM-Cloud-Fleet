// Generated by gencpp from file sensors/IMUData.msg
// DO NOT EDIT!


#ifndef SENSORS_MESSAGE_IMUDATA_H
#define SENSORS_MESSAGE_IMUDATA_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace sensors
{
template <class ContainerAllocator>
struct IMUData_
{
  typedef IMUData_<ContainerAllocator> Type;

  IMUData_()
    : AxCalib(0.0)
    , AyCalib(0.0)
    , AzCalib(0.0)
    , Ax(0.0)
    , Ay(0.0)
    , Az(0.0)
    , AxRaw(0.0)
    , AyRaw(0.0)
    , AzRaw(0.0)
    , Vx(0.0)
    , Vy(0.0)
    , Vz(0.0)
    , Gx(0.0)
    , Gy(0.0)
    , Gz(0.0)
    , GxCalib(0.0)
    , GyCalib(0.0)
    , GzCalib(0.0)
    , GxRaw(0.0)
    , GyRaw(0.0)
    , GzRaw(0.0)
    , currTime(0.0)  {
    }
  IMUData_(const ContainerAllocator& _alloc)
    : AxCalib(0.0)
    , AyCalib(0.0)
    , AzCalib(0.0)
    , Ax(0.0)
    , Ay(0.0)
    , Az(0.0)
    , AxRaw(0.0)
    , AyRaw(0.0)
    , AzRaw(0.0)
    , Vx(0.0)
    , Vy(0.0)
    , Vz(0.0)
    , Gx(0.0)
    , Gy(0.0)
    , Gz(0.0)
    , GxCalib(0.0)
    , GyCalib(0.0)
    , GzCalib(0.0)
    , GxRaw(0.0)
    , GyRaw(0.0)
    , GzRaw(0.0)
    , currTime(0.0)  {
  (void)_alloc;
    }



   typedef double _AxCalib_type;
  _AxCalib_type AxCalib;

   typedef double _AyCalib_type;
  _AyCalib_type AyCalib;

   typedef double _AzCalib_type;
  _AzCalib_type AzCalib;

   typedef double _Ax_type;
  _Ax_type Ax;

   typedef double _Ay_type;
  _Ay_type Ay;

   typedef double _Az_type;
  _Az_type Az;

   typedef double _AxRaw_type;
  _AxRaw_type AxRaw;

   typedef double _AyRaw_type;
  _AyRaw_type AyRaw;

   typedef double _AzRaw_type;
  _AzRaw_type AzRaw;

   typedef double _Vx_type;
  _Vx_type Vx;

   typedef double _Vy_type;
  _Vy_type Vy;

   typedef double _Vz_type;
  _Vz_type Vz;

   typedef double _Gx_type;
  _Gx_type Gx;

   typedef double _Gy_type;
  _Gy_type Gy;

   typedef double _Gz_type;
  _Gz_type Gz;

   typedef double _GxCalib_type;
  _GxCalib_type GxCalib;

   typedef double _GyCalib_type;
  _GyCalib_type GyCalib;

   typedef double _GzCalib_type;
  _GzCalib_type GzCalib;

   typedef double _GxRaw_type;
  _GxRaw_type GxRaw;

   typedef double _GyRaw_type;
  _GyRaw_type GyRaw;

   typedef double _GzRaw_type;
  _GzRaw_type GzRaw;

   typedef double _currTime_type;
  _currTime_type currTime;





  typedef boost::shared_ptr< ::sensors::IMUData_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::sensors::IMUData_<ContainerAllocator> const> ConstPtr;

}; // struct IMUData_

typedef ::sensors::IMUData_<std::allocator<void> > IMUData;

typedef boost::shared_ptr< ::sensors::IMUData > IMUDataPtr;
typedef boost::shared_ptr< ::sensors::IMUData const> IMUDataConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::sensors::IMUData_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::sensors::IMUData_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::sensors::IMUData_<ContainerAllocator1> & lhs, const ::sensors::IMUData_<ContainerAllocator2> & rhs)
{
  return lhs.AxCalib == rhs.AxCalib &&
    lhs.AyCalib == rhs.AyCalib &&
    lhs.AzCalib == rhs.AzCalib &&
    lhs.Ax == rhs.Ax &&
    lhs.Ay == rhs.Ay &&
    lhs.Az == rhs.Az &&
    lhs.AxRaw == rhs.AxRaw &&
    lhs.AyRaw == rhs.AyRaw &&
    lhs.AzRaw == rhs.AzRaw &&
    lhs.Vx == rhs.Vx &&
    lhs.Vy == rhs.Vy &&
    lhs.Vz == rhs.Vz &&
    lhs.Gx == rhs.Gx &&
    lhs.Gy == rhs.Gy &&
    lhs.Gz == rhs.Gz &&
    lhs.GxCalib == rhs.GxCalib &&
    lhs.GyCalib == rhs.GyCalib &&
    lhs.GzCalib == rhs.GzCalib &&
    lhs.GxRaw == rhs.GxRaw &&
    lhs.GyRaw == rhs.GyRaw &&
    lhs.GzRaw == rhs.GzRaw &&
    lhs.currTime == rhs.currTime;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::sensors::IMUData_<ContainerAllocator1> & lhs, const ::sensors::IMUData_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace sensors

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::sensors::IMUData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::sensors::IMUData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::sensors::IMUData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::sensors::IMUData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::sensors::IMUData_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::sensors::IMUData_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::sensors::IMUData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "6bda55b7f9e6f3956c206b862be8ffbe";
  }

  static const char* value(const ::sensors::IMUData_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x6bda55b7f9e6f395ULL;
  static const uint64_t static_value2 = 0x6c206b862be8ffbeULL;
};

template<class ContainerAllocator>
struct DataType< ::sensors::IMUData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "sensors/IMUData";
  }

  static const char* value(const ::sensors::IMUData_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::sensors::IMUData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64 AxCalib\n"
"float64 AyCalib\n"
"float64 AzCalib\n"
"float64 Ax\n"
"float64 Ay\n"
"float64 Az\n"
"float64 AxRaw\n"
"float64 AyRaw\n"
"float64 AzRaw\n"
"float64 Vx\n"
"float64 Vy\n"
"float64 Vz\n"
"float64 Gx\n"
"float64 Gy\n"
"float64 Gz\n"
"float64 GxCalib\n"
"float64 GyCalib\n"
"float64 GzCalib\n"
"float64 GxRaw\n"
"float64 GyRaw\n"
"float64 GzRaw\n"
"float64 currTime\n"
;
  }

  static const char* value(const ::sensors::IMUData_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::sensors::IMUData_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.AxCalib);
      stream.next(m.AyCalib);
      stream.next(m.AzCalib);
      stream.next(m.Ax);
      stream.next(m.Ay);
      stream.next(m.Az);
      stream.next(m.AxRaw);
      stream.next(m.AyRaw);
      stream.next(m.AzRaw);
      stream.next(m.Vx);
      stream.next(m.Vy);
      stream.next(m.Vz);
      stream.next(m.Gx);
      stream.next(m.Gy);
      stream.next(m.Gz);
      stream.next(m.GxCalib);
      stream.next(m.GyCalib);
      stream.next(m.GzCalib);
      stream.next(m.GxRaw);
      stream.next(m.GyRaw);
      stream.next(m.GzRaw);
      stream.next(m.currTime);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct IMUData_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::sensors::IMUData_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::sensors::IMUData_<ContainerAllocator>& v)
  {
    s << indent << "AxCalib: ";
    Printer<double>::stream(s, indent + "  ", v.AxCalib);
    s << indent << "AyCalib: ";
    Printer<double>::stream(s, indent + "  ", v.AyCalib);
    s << indent << "AzCalib: ";
    Printer<double>::stream(s, indent + "  ", v.AzCalib);
    s << indent << "Ax: ";
    Printer<double>::stream(s, indent + "  ", v.Ax);
    s << indent << "Ay: ";
    Printer<double>::stream(s, indent + "  ", v.Ay);
    s << indent << "Az: ";
    Printer<double>::stream(s, indent + "  ", v.Az);
    s << indent << "AxRaw: ";
    Printer<double>::stream(s, indent + "  ", v.AxRaw);
    s << indent << "AyRaw: ";
    Printer<double>::stream(s, indent + "  ", v.AyRaw);
    s << indent << "AzRaw: ";
    Printer<double>::stream(s, indent + "  ", v.AzRaw);
    s << indent << "Vx: ";
    Printer<double>::stream(s, indent + "  ", v.Vx);
    s << indent << "Vy: ";
    Printer<double>::stream(s, indent + "  ", v.Vy);
    s << indent << "Vz: ";
    Printer<double>::stream(s, indent + "  ", v.Vz);
    s << indent << "Gx: ";
    Printer<double>::stream(s, indent + "  ", v.Gx);
    s << indent << "Gy: ";
    Printer<double>::stream(s, indent + "  ", v.Gy);
    s << indent << "Gz: ";
    Printer<double>::stream(s, indent + "  ", v.Gz);
    s << indent << "GxCalib: ";
    Printer<double>::stream(s, indent + "  ", v.GxCalib);
    s << indent << "GyCalib: ";
    Printer<double>::stream(s, indent + "  ", v.GyCalib);
    s << indent << "GzCalib: ";
    Printer<double>::stream(s, indent + "  ", v.GzCalib);
    s << indent << "GxRaw: ";
    Printer<double>::stream(s, indent + "  ", v.GxRaw);
    s << indent << "GyRaw: ";
    Printer<double>::stream(s, indent + "  ", v.GyRaw);
    s << indent << "GzRaw: ";
    Printer<double>::stream(s, indent + "  ", v.GzRaw);
    s << indent << "currTime: ";
    Printer<double>::stream(s, indent + "  ", v.currTime);
  }
};

} // namespace message_operations
} // namespace ros

#endif // SENSORS_MESSAGE_IMUDATA_H

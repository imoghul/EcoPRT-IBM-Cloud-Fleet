from imuController import *
import time
import numpy as np
from invoke import *

# this function will determine the number of additional elements needed before
# sending the data to the cloud after processing
#~~~~~~~~~
# CHECK UNITS ON VELOCITY FROM IMU DATA!!!~~~!!!
#~~~~~~~~~
def queueScaling(speed):
	if speed * 2.23694 < 5:    # send the full 3 seconds of data
		return 1500
	elif speed * 2.23694 < 10: # send 2.25 seconds of data
		return 1125
	elif speed * 2.23694 < 15: # send 1.5 seconds of data
		return 750
	else:			   # send 1 second of data
		return 500

def processIMU(thresh,accelData):
	duration = 0
	magnitude = 0.0
	max = 0.0
	qualityScore = 0

	# Determine the severity, duration, and max values
	for point in accelData:
		if point > 0.01:
			duration += 1
			magnitude += abs(accelData[point])
			if abs(accelData[point]) > max:
				max = abs(accelData[point])
	severity = magnitude / duration

	# Determine quality score based on threshold values
	if thresh == "high":
		qualityScore = (1000 * severity + 500 * duration + 100 * max)/1600
	elif thres == "low for time":
		qualityScore = (500 * severity + 1000 * duration + 100 * max)/1600

	# more testing will need to be done here to know how best to 
	# normalize the road score data
	qualityScore = round(qualityScore / 0.01, 0)

	return qualityScore

controller = IMUController()
controller.start()

run = True
drift = [[0.0000060728,0.0013608],[0.0000031578,-0.00030711],[-0.000012169,0.00021297]]
Az = []
Gx = []
Gy = []
duration = 0.0
pointSend = 0
pointCounter = 0
logging = False
sendData = False
roadScore = 0
checkDuration = False
threshold = None

while run:
	# populate the queue
	if len(Az) < 3000:
		Az.append(controller.Az)
		Gx.append(controller.Gx)
		Gy.append(controller.Gy)
	else:
		Az.popleft()
		Gx.popleft()
		Gz.popleft()
		Az.append(controller.Az)
		Gx.append(controller.Gx)
		Gy.append(controller.Gy)

	# count down the number of instances
	if pointCounter != 0:
		pointCounter -= 1
	# if the number of data points is done being logged,
	# set the flag to send the data
	elif pointCounter == 0 and logging:
		sendData = True
		logging = False

	# Check for rough road
	# Need to account for gyroscope measurements in the if statements.
	if abs(controller.Az) > 0.03 and pointCounter == 0:
		threshold = "high"
		pointCounter = queueScaling(controller.Vx)
		pointSend = 2 * pointCounter
		logging = True
	elif abs(controller.Az) > 0.01 and duration >= 0.5 and pointCounter == 0:
		threshold = "low for time"
		pointCounter = queueScaling(controller.Vx)
		pointSend = 2 * pointCounter
		logging = True
	elif mean(abs(Az[-500:])) > 0.008 and len(Az) > 500:
		durration += 0.001
	else:
		durration = 0

	# Check if data needs to be sent
	if sendData:
		roadScore = processIMU(threshold,Az[-pointSend:])
#		putDataToCloud({"road quality score":roadScore,"IMU Data":Az})
# uncomment the above line when ready to send data to the cloud
		sendData = False
		run = False



dataStruct()
print("Data Sent to Cloud")
controller.end()
